---
layout: post
title: "TCA - SwiftUI 的救星？(三)"
date: 2022-01-04 09:50:00.000000000 +09:00
categories: [能工巧匠集, SwiftUI]
tags: [swift, 编程语言, swiftui, tca, elm]
typora-root-url: ..
---

在[上一篇关于 TCA 的文章](https://onevcat.com/2021/12/tca-2/)中，我们通过看到了绑定的工作方式以及 Environment 在管理依赖和提供易测试性时发挥的作用。在这篇文章中，我们会继续深入，看看 TCA 中的 `Effect` 角色到底是什么，以及如何通过组合的方式来把多个 Feature 组合在一起，形成更加复杂的 UI 结构。

> 如果你想要跟做，可以直接使用上一篇文章完成练习后最后的状态，或者从[这里](https://github.com/onevcat/CounterDemo/releases/tag/part-2-finish)获取到起始代码。

## Effect

Elm-like 的状态管理之所以能够保持可测试及可扩展，核心要求是 Reducer 的纯函数特性。Environment 通过提供依赖解决了输入阶段的副作用，比如 reducer 需要获取某个 `Date` 等，
而 Effect 解决的则是输出阶段的副作用：如果在 Reducer 接收到某个行为之后，需要作出非状态变化的反应，比如发送一个网络请求、向硬盘写一些数据、或者甚至是监听某个通知等，都需要通过返回 `Effect` 进行。

在 Counter app 当前的实现里，在 `counterReducer` 的所有 case 中，我们返回的都是 `.none` 这个 Effect，也就是说，一个什么都不做的 Effect。


## Composable
